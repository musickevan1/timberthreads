---
phase: 02-gallery-migration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/components/Gallery.tsx
  - src/components/LightboxGallery.tsx
  - src/components/ZoomableImage.tsx
  - src/app/admin/gallery/components/GalleryItem.tsx
  - src/app/admin/gallery/components/UploadSection.tsx
  - src/app/admin/gallery/page.tsx
  - src/app/api/gallery/route.ts
  - next.config.js
autonomous: true

must_haves:
  truths:
    - "Gallery displays all images from Cloudinary with automatic format optimization (WebP/AVIF)"
    - "Gallery implements lazy loading: first 6 images eager, rest lazy"
    - "Admin can upload new images via CldUploadWidget with drag-and-drop"
    - "Admin can reorder, edit captions, and soft-delete images with changes persisting"
    - "Lightbox displays Cloudinary images correctly with zoom functionality"
    - "No broken image links or 404 errors"
  artifacts:
    - path: "src/components/Gallery.tsx"
      provides: "Public gallery with CldImage and lazy loading"
      contains: "CldImage"
    - path: "src/components/ZoomableImage.tsx"
      provides: "Lightbox zoom with CldImage"
      contains: "CldImage"
    - path: "src/app/admin/gallery/components/UploadSection.tsx"
      provides: "Admin upload via CldUploadWidget"
      contains: "CldUploadWidget"
    - path: "src/app/admin/gallery/components/GalleryItem.tsx"
      provides: "Admin gallery item with CldImage"
      contains: "CldImage"
    - path: "src/app/api/gallery/route.ts"
      provides: "JSON-based POST handler for widget uploads"
      contains: "application/json"
  key_links:
    - from: "src/components/Gallery.tsx"
      to: "Cloudinary CDN"
      via: "CldImage src={image.src} renders as Cloudinary URL"
      pattern: "CldImage.*src=\\{image\\.src\\}"
    - from: "src/app/admin/gallery/components/UploadSection.tsx"
      to: "/api/cloudinary-signature"
      via: "CldUploadWidget signatureEndpoint for signed uploads"
      pattern: "signatureEndpoint.*cloudinary-signature"
    - from: "src/app/admin/gallery/components/UploadSection.tsx"
      to: "/api/gallery POST"
      via: "onSuccess callback saves metadata to Redis"
      pattern: "fetch.*api/gallery.*POST"
    - from: "src/app/api/gallery/route.ts"
      to: "src/lib/redis.ts"
      via: "saveGalleryData for widget upload metadata"
      pattern: "saveGalleryData"
---

<objective>
Update all frontend components to use next-cloudinary (CldImage, CldUploadWidget) for optimal Cloudinary integration.

Purpose: After Plan 01 migrated images to Cloudinary, this plan updates the rendering layer. CldImage provides automatic f_auto (format) and q_auto (quality) optimizations that plain Next.js Image with remotePatterns cannot. CldUploadWidget replaces the manual FormData upload with a polished drag-and-drop widget that uploads directly to Cloudinary from the browser.

Output: All gallery images render via CldImage with lazy loading, admin uploads use CldUploadWidget, all CRUD operations work end-to-end.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-gallery-migration/02-RESEARCH.md
@.planning/phases/02-gallery-migration/02-01-SUMMARY.md

@src/components/Gallery.tsx
@src/components/LightboxGallery.tsx
@src/components/ZoomableImage.tsx
@src/app/admin/gallery/page.tsx
@src/app/admin/gallery/components/UploadSection.tsx
@src/app/admin/gallery/components/GalleryItem.tsx
@src/app/api/gallery/route.ts
@src/app/api/gallery/types.ts
@src/app/api/cloudinary-signature/route.ts
@next.config.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update public Gallery, Lightbox, and ZoomableImage to use CldImage with lazy loading</name>
  <files>src/components/Gallery.tsx, src/components/LightboxGallery.tsx, src/components/ZoomableImage.tsx</files>
  <action>
**Gallery.tsx changes:**

1. Replace `import Image from 'next/image'` with `import { CldImage } from 'next-cloudinary'`.

2. Create a helper to render images that handles both Cloudinary public_ids and any remaining local paths (defensive, though Plan 01 should have migrated all):
   - If `image.src` starts with `/`, render with regular next/image `Image` (fallback for any unmigrated images)
   - Otherwise render with `CldImage`

3. Implement lazy loading strategy: Track the global index across both sections. The first 6 images total (across Facility + Quilting) get `priority={true}` and `loading="eager"`. The rest get default lazy loading.

4. Replace the `<Image>` tag in the facility images grid with:
```tsx
<CldImage
  src={image.src}
  alt={image.alt}
  width={800}
  height={533}
  crop="fill"
  gravity="auto"
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
  priority={globalIndex < 6}
  loading={globalIndex < 6 ? 'eager' : 'lazy'}
/>
```

5. Do the same for quilting images grid, continuing the global index count from where facility images left off.

6. Remove the `quality={80}` prop - CldImage applies q_auto automatically.

7. Remove the `fill` prop and use explicit width/height instead. CldImage with fill behaves differently from next/image. Use `width={800} height={533}` (roughly 3:2 aspect ratio matching aspect-video container). The existing `aspect-video` container CSS will handle visual sizing. Remove the `relative` class from the image wrapper div that was needed for `fill` mode, and adjust layout: remove the inner `<div className="aspect-video relative overflow-hidden...">` wrapper's `relative` positioning requirement since CldImage won't use `fill`. Instead, add `className="w-full h-full object-cover ..."` to CldImage and keep the `aspect-video` container.

Actually, simpler approach: Keep the aspect-video container as-is. Use CldImage with explicit width/height and add `className="object-cover w-full h-full"` plus `style={{ position: 'absolute', inset: 0 }}` if needed, OR use the `fill` approach if CldImage supports it. CldImage DOES support `fill` - it wraps next/image. So keep `fill` but remove the explicit `quality` prop:

```tsx
<CldImage
  src={image.src}
  alt={image.alt}
  fill
  crop="fill"
  gravity="auto"
  className="object-cover transition-transform duration-300 group-hover:scale-105"
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
  priority={globalIndex < 6}
/>
```

Note: When using CldImage with `fill`, the parent must have `position: relative` (the existing `relative` on `aspect-video` div satisfies this).

8. Compute the globalIndex: Before rendering, concatenate facilityImages and quiltingImages into a single ordered list to determine each image's global position. Or simpler: pass the facility count as an offset to the quilting section:
```tsx
// facilityImages render with index 0..N-1
// quiltingImages render with index facilityImages.length..N+M-1
```

**LightboxGallery.tsx changes:**

1. Add `import { CldImage } from 'next-cloudinary'`.
2. The LightboxGallery passes `src` and `alt` to ZoomableImage. No direct Image usage here - changes happen in ZoomableImage.
3. No changes needed to LightboxGallery itself, but verify props still work after ZoomableImage changes.

**ZoomableImage.tsx changes:**

1. Replace `import Image from 'next/image'` with `import { CldImage } from 'next-cloudinary'`.
2. Replace the `<Image>` tag with:
```tsx
<CldImage
  src={src}
  alt={alt}
  fill
  className="object-contain"
  sizes="100vw"
  onLoad={onLoadingComplete}
/>
```
3. Note: CldImage uses `onLoad` instead of the deprecated `onLoadingComplete`. Check if the component uses `onLoadingComplete` prop name - if so, update the callback prop name.
4. Remove `quality={85}` - CldImage applies q_auto.
5. Add fallback for local paths: If `src.startsWith('/')`, use regular `Image` from next/image instead.
  </action>
  <verify>
    - `npm run build` completes without errors
    - `grep -r "CldImage" src/components/Gallery.tsx` shows CldImage usage
    - `grep -r "CldImage" src/components/ZoomableImage.tsx` shows CldImage usage
    - `grep -r "priority" src/components/Gallery.tsx` shows priority prop usage for lazy loading
    - No `import Image from 'next/image'` in Gallery.tsx (unless kept as fallback for local paths)
  </verify>
  <done>Public Gallery renders all images via CldImage with automatic format optimization. First 6 images load eagerly, rest lazy load. Lightbox and zoom work with Cloudinary images.</done>
</task>

<task type="auto">
  <name>Task 2: Update admin components - CldUploadWidget and CldImage for GalleryItem</name>
  <files>src/app/admin/gallery/components/UploadSection.tsx, src/app/admin/gallery/components/GalleryItem.tsx, src/app/admin/gallery/page.tsx, src/app/api/gallery/route.ts, next.config.js</files>
  <action>
**UploadSection.tsx - Replace dropzone with CldUploadWidget:**

1. Remove `react-dropzone` import and all dropzone-related state/logic (useDropzone, isDragActive, onDrop, getRootProps, getInputProps).
2. Import `{ CldUploadWidget }` from `'next-cloudinary'` and `type { CloudinaryUploadWidgetResults }` from `'next-cloudinary'`.
3. Update the component props interface: Remove `handleImageUpload` prop. Add `onUploadSuccess: () => void` prop and `section: 'Facility' | 'Quilting'` prop (the current section for tagging).
4. Replace the dropzone UI with CldUploadWidget:

```tsx
<CldUploadWidget
  signatureEndpoint="/api/cloudinary-signature"
  options={{
    folder: 'timber-threads/gallery',
    tags: [section.toLowerCase(), 'gallery'],
    maxFiles: 1,
    sources: ['local', 'url'],
    multiple: false,
    resourceType: 'image',
    clientAllowedFormats: ['jpg', 'jpeg', 'png', 'webp', 'gif'],
    maxFileSize: 10000000,
  }}
  onSuccess={async (result: CloudinaryUploadWidgetResults) => {
    if (result.info && typeof result.info !== 'string') {
      const { public_id, width, height } = result.info;

      // Save metadata to Redis via existing API
      try {
        const response = await fetch('/api/gallery', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            src: public_id,
            alt: public_id.split('/').pop() || 'Gallery image',
            caption: (public_id.split('/').pop() || 'Image')
              .replace(/-/g, ' ')
              .replace(/_/g, ' ')
              .split(' ')
              .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
              .join(' '),
            section,
            width,
            height,
          }),
        });

        if (!response.ok) throw new Error('Failed to save image metadata');
        onUploadSuccess();
      } catch (error) {
        console.error('Error saving upload metadata:', error);
      }
    }
  }}
>
  {({ open }) => (
    <div className="bg-stone-50 p-6 rounded-lg border-2 border-dashed border-stone-200 cursor-pointer hover:border-teal-500 hover:bg-teal-50 transition-colors"
         onClick={() => open()}>
      <div className="flex flex-col items-center justify-center py-6 text-center">
        <svg xmlns="http://www.w3.org/2000/svg" className="h-12 w-12 mb-4 text-stone-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
        </svg>
        <p className="text-lg font-medium text-stone-700">Click to upload an image</p>
        <p className="mt-2 text-sm text-stone-500">Supports JPG, PNG, GIF, and WebP up to 10MB</p>
        <button type="button" className="mt-4 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-teal-600 hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500">
          Select Image
        </button>
      </div>
    </div>
  )}
</CldUploadWidget>
```

5. Keep the upload error display and image count display.
6. Remove the `isUploading`, `uploadProgress` props since CldUploadWidget handles its own progress UI.

**GalleryItem.tsx - Replace Image with CldImage:**

1. Replace `import Image from 'next/image'` with `import { CldImage } from 'next-cloudinary'`.
2. Replace the `<Image>` tag with:
```tsx
<CldImage
  src={image.src}
  alt={image.alt}
  fill
  crop="fill"
  gravity="auto"
  className="object-cover transition-transform duration-300 group-hover:scale-105"
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
/>
```
3. Remove `priority` (admin doesn't need LCP optimization) and `quality={85}`.
4. Add fallback: if `image.src.startsWith('/')`, use regular `Image` from next/image.

**gallery/page.tsx - Update props for new UploadSection:**

1. Update UploadSection usage to pass the new props:
   - Remove: `isUploading`, `uploadProgress`, `uploadError`, `handleImageUpload` props
   - Add: `section={getImageSection(activeTab)}`, `onUploadSuccess={() => fetchGalleryData()}`
2. Remove `isUploading`, `uploadProgress`, `uploadError` state variables (CldUploadWidget handles its own state).
3. Remove the `handleImageUpload` function entirely (uploads now go directly to Cloudinary via widget).
4. Keep all other handlers (handleSoftDelete, handleRestore, handleUpdateCaption, handlePermanentDelete, handleSectionChange) - these work unchanged since they use image.src which is now a Cloudinary public_id.

**gallery/route.ts - Add JSON POST handler for widget uploads:**

1. Modify the POST handler to detect content type:
   - If `content-type` contains `multipart/form-data`: use existing FormData flow (backward compatibility)
   - If `content-type` contains `application/json`: new flow for CldUploadWidget uploads
2. The JSON flow accepts: `{ src, alt, caption, section, width, height }`
   - `src` is the Cloudinary public_id (already uploaded by widget)
   - Creates ImageAsset with the provided data
   - Sets order to max+1 in the section
   - Saves to Redis via saveGalleryData
   - Does NOT upload to Cloudinary (widget already did this)
   - Does NOT use Sharp (no file to process)
3. Keep the FormData flow for backward compatibility but it can be simplified later.

```typescript
export async function POST(request: NextRequest) {
  try {
    const contentType = request.headers.get('content-type') || '';

    if (contentType.includes('application/json')) {
      // CldUploadWidget flow: image already on Cloudinary
      const { src, alt, caption, section, width, height } = await request.json();

      if (!src || !section) {
        return NextResponse.json(
          { error: 'src and section are required' },
          { status: 400 }
        );
      }

      const db = await getGalleryData();
      const maxOrder = db.images
        .filter(img => img.section === section)
        .reduce((max, img) => Math.max(max, img.order || 0), 0);

      const newImage: ImageAsset = {
        src,
        alt: alt || src.split('/').pop() || 'Gallery image',
        caption: caption || '',
        section,
        order: maxOrder + 1,
        metadata: {
          uploadedAt: new Date().toISOString(),
          dimensions: width && height ? { width, height } : undefined,
        },
      };

      db.images.push(newImage);
      await saveGalleryData(db);

      return NextResponse.json({
        message: 'Image added successfully',
        image: newImage,
      });
    }

    // Existing FormData flow (backward compatibility)
    // ... keep existing code ...
  }
}
```

**next.config.js - Update CSP for CldUploadWidget:**

The CldUploadWidget loads external scripts and iframes from Cloudinary. Update the Content-Security-Policy header:
- Add `https://upload-widget.cloudinary.com` to `script-src`
- Add `https://upload-widget.cloudinary.com` to `frame-src`
- Add `https://widget.cloudinary.com https://upload-widget.cloudinary.com` to `connect-src`
- Add `https://upload-widget.cloudinary.com` to `style-src`

Update the CSP value string in the headers() function accordingly. Be careful to preserve all existing CSP directives.
  </action>
  <verify>
    - `npm run build` completes without errors
    - `grep -r "CldUploadWidget" src/app/admin/gallery/components/UploadSection.tsx` shows widget usage
    - `grep -r "CldImage" src/app/admin/gallery/components/GalleryItem.tsx` shows CldImage usage
    - `grep -r "signatureEndpoint" src/app/admin/gallery/components/UploadSection.tsx` shows signed upload config
    - `grep -r "application/json" src/app/api/gallery/route.ts` shows JSON POST handler
    - `grep "upload-widget.cloudinary.com" next.config.js` shows CSP update
  </verify>
  <done>Admin upload uses CldUploadWidget with signed uploads via existing signature endpoint. GalleryItem renders with CldImage. Gallery POST handler accepts both JSON (widget) and FormData (legacy). CSP allows Cloudinary widget resources.</done>
</task>

<task type="auto">
  <name>Task 3: End-to-end build verification and cleanup</name>
  <files></files>
  <action>
Run comprehensive verification to ensure everything works together:

1. Run `npm run build` to verify no compilation errors with all the CldImage/CldUploadWidget changes.

2. Verify the build output shows no warnings about:
   - Missing CldImage width/height (when using fill)
   - Deprecated `onLoadingComplete` usage
   - Missing environment variables (CldImage needs NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME at build time)

3. If NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME is not set in the build environment, CldImage will fail silently. Check if `.env.local` has this variable set. If not, the build will still succeed but images won't render - this is expected and will be resolved when user sets up Cloudinary credentials.

4. Verify no remaining `import Image from 'next/image'` in files that should have been migrated:
   - Gallery.tsx should use CldImage (may keep Image as fallback)
   - ZoomableImage.tsx should use CldImage (may keep Image as fallback)
   - GalleryItem.tsx should use CldImage (may keep Image as fallback)

5. Verify lazy loading implementation:
   - Gallery.tsx should have priority={index < 6} or similar pattern for first 6 images
   - No `priority={true}` on GalleryItem.tsx (admin doesn't need it)

6. Run `npm run lint` if available to check for any linting issues.

7. Verify the react-dropzone package is still needed. If UploadSection was the only consumer and it now uses CldUploadWidget, react-dropzone can be removed: `npm uninstall react-dropzone`. Check if any other file imports react-dropzone first.
  </action>
  <verify>
    - `npm run build` exits with code 0
    - `npm run lint` exits with code 0 (or warns only, no errors)
    - No TypeScript errors related to CldImage or CldUploadWidget
  </verify>
  <done>Full build succeeds. All components use CldImage for Cloudinary images. Admin uses CldUploadWidget. Lazy loading configured (first 6 eager, rest lazy). No unused dependencies.</done>
</task>

</tasks>

<verification>
Phase 2 success criteria verification:
1. All existing gallery images are hosted on Cloudinary CDN (Plan 01 migrated, Plan 02 renders via CldImage)
2. Admin can upload new images via CldUploadWidget with changes persisting (UploadSection + POST JSON handler + Redis)
3. Admin can reorder, edit captions, and soft-delete with persistence (PATCH handlers unchanged, work with public_ids)
4. Gallery displays with automatic format optimization (CldImage applies f_auto/q_auto)
5. Gallery implements lazy loading (first 6 eager via priority prop, rest lazy)
6. No broken image links (all images are Cloudinary public_ids, CldImage constructs correct URLs)
</verification>

<success_criteria>
- `npm run build` succeeds with zero errors
- All gallery images render via CldImage (not plain next/image Image)
- First 6 gallery images have priority={true}, rest lazy load
- Admin upload uses CldUploadWidget with signed uploads
- POST /api/gallery accepts JSON body from widget uploads
- All existing CRUD operations (reorder, caption edit, soft-delete, restore, permanent delete) work unchanged
- CSP headers allow Cloudinary upload widget resources
</success_criteria>

<output>
After completion, create `.planning/phases/02-gallery-migration/02-02-SUMMARY.md`
</output>

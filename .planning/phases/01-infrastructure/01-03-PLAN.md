---
phase: 01-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified: [src/app/api/gallery/route.ts, next.config.js]
autonomous: true

must_haves:
  truths:
    - "Gallery images upload to Cloudinary CDN instead of local filesystem"
    - "Gallery API saves Cloudinary public_id in metadata instead of file paths"
    - "Next.js Image optimization enabled for Cloudinary images"
    - "Admin can upload test image and it persists in production"
  artifacts:
    - path: "src/app/api/gallery/route.ts"
      provides: "Updated POST handler uploading to Cloudinary"
      contains: "cloudinary.uploader.upload"
    - path: "next.config.js"
      provides: "Image optimization configuration for Cloudinary"
      contains: "res.cloudinary.com"
  key_links:
    - from: "src/app/api/gallery/route.ts"
      to: "Cloudinary API"
      via: "cloudinary.uploader.upload for image storage"
      pattern: "cloudinary\\.uploader\\.upload"
    - from: "next.config.js"
      to: "Cloudinary CDN"
      via: "remotePatterns allowing res.cloudinary.com"
      pattern: "res\\.cloudinary\\.com"
---

<objective>
Migrate gallery image uploads from local filesystem to Cloudinary CDN and enable Next.js Image optimization.

Purpose: Complete cloud infrastructure migration, enabling persistent image storage in production and automatic format optimization (WebP/AVIF).
Output: Gallery uploads to Cloudinary, Next.js Image component configured for CDN delivery.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/phase-1-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md

# Depends on Plan 01 and 02 outputs:
@.planning/phases/01-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-infrastructure/01-02-SUMMARY.md

@src/app/api/gallery/route.ts
@src/app/api/gallery/types.ts
@next.config.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update gallery POST handler to upload to Cloudinary</name>
  <files>src/app/api/gallery/route.ts</files>
  <action>
Update the POST handler in src/app/api/gallery/route.ts to upload images to Cloudinary instead of local filesystem.

Changes required:

1. **Add Cloudinary import** (after other imports):
   ```typescript
   import { cloudinary } from '@/lib/cloudinary';
   ```

2. **Remove local filesystem upload code** (lines 95-102):
   ```typescript
   // DELETE THESE LINES:
   // const filename = `${file.name.split('.')[0]}-${Date.now()}.webp`.toLowerCase().replace(/\s+/g, '-');
   // const publicPath = `/assets/gallery/${filename}`;
   // const publicDir = path.join(process.cwd(), 'public', 'assets', 'gallery');
   // await mkdir(publicDir, { recursive: true });
   // await fsWriteFile(path.join(publicDir, filename), optimizedImageBuffer);
   ```

3. **Add Cloudinary upload** (replace deleted lines with):
   ```typescript
   // Convert optimized buffer to base64 for Cloudinary upload
   const base64Image = `data:image/webp;base64,${optimizedImageBuffer.toString('base64')}`;

   // Upload to Cloudinary with transformations
   const uploadResult = await cloudinary.uploader.upload(base64Image, {
     folder: 'timber-threads/gallery',
     public_id: `${Date.now()}-${file.name.split('.')[0].toLowerCase().replace(/\s+/g, '-')}`,
     transformation: [
       { width: 1920, height: 1080, crop: 'limit' },
       { quality: 'auto:good', fetch_format: 'auto' }
     ],
     tags: [section.toLowerCase(), 'gallery']
   });

   console.log('Image uploaded to Cloudinary:', uploadResult.public_id);
   ```

4. **Update newImage object** to use Cloudinary public_id (line 112):
   ```typescript
   const newImage: ImageAsset = {
     src: uploadResult.public_id, // CHANGED: Cloudinary public_id instead of file path
     alt: file.name.split('.')[0],
     caption,
     section,
     order: maxOrder + 1,
     metadata: {
       uploadedAt: new Date().toISOString(),
       dimensions: {
         width: uploadResult.width,
         height: uploadResult.height
       }
     }
   };
   ```

Why this implementation:
- Keep Sharp optimization (resize + WebP conversion) before uploading to Cloudinary - reduces bandwidth and upload time
- Cloudinary public_id format: `timestamp-filename` for uniqueness
- Cloudinary transformations (quality: auto:good, fetch_format: auto) enable automatic WebP/AVIF serving based on browser support
- Tags enable filtering by section in Cloudinary dashboard
- Folder structure keeps gallery images organized

What NOT to change:
- Keep Sharp image processing (lines 84-93) - optimizes before upload to save bandwidth
- Keep file size validation (line 74) - prevents large uploads
- Keep Redis metadata operations from Plan 01 - already migrated
- Do NOT update DELETE handler yet (permanent deletion can reference Cloudinary API in future)
  </action>
  <verify>
- grep "cloudinary.uploader.upload" src/app/api/gallery/route.ts confirms Cloudinary upload
- grep "publicPath.*assets/gallery" src/app/api/gallery/route.ts returns nothing (local filesystem removed)
- grep "uploadResult.public_id" src/app/api/gallery/route.ts confirms public_id usage
- npm run build succeeds
  </verify>
  <done>Gallery POST handler uploads images to Cloudinary and stores public_id in metadata</done>
</task>

<task type="auto">
  <name>Task 2: Enable Next.js Image optimization and configure Cloudinary remote patterns</name>
  <files>next.config.js</files>
  <action>
Update next.config.js to enable Image optimization and allow Cloudinary CDN.

Changes required:

1. **Remove unoptimized flag** (line 4):
   ```javascript
   // DELETE THIS LINE:
   // unoptimized: true,
   ```

2. **Update remotePatterns** to specifically allow Cloudinary (lines 5-10):
   ```javascript
   remotePatterns: [
     {
       protocol: 'https',
       hostname: 'res.cloudinary.com',
       pathname: `/${process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME}/**`,
     },
     // Keep existing external image sources
     {
       protocol: 'https',
       hostname: '*.facebook.com',
     },
     {
       protocol: 'https',
       hostname: '*.fbsbx.com',
     },
     {
       protocol: 'https',
       hostname: 'www.google.com',
     },
   ],
   ```

3. **Update Content Security Policy** to allow Cloudinary (line 20):
   ```javascript
   // ADD Cloudinary to img-src directive:
   value: "default-src 'self'; connect-src 'self' https://*.facebook.com https://www.google.com; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://*.facebook.net https://*.facebook.com https://www.google.com; frame-src https://*.facebook.com https://calendar.google.com https://www.google.com/maps/embed; style-src 'self' 'unsafe-inline' https://*.facebook.com; font-src 'self' data: https://*.facebook.com; img-src 'self' https://*.facebook.com https://*.fbsbx.com https://www.google.com https://res.cloudinary.com data:; media-src 'self' https://res.cloudinary.com;"
   ```

Why this configuration:
- Removing `unoptimized: true` enables Next.js Image optimization (automatic format conversion, responsive sizing, lazy loading)
- Specific Cloudinary hostname instead of wildcard `**` improves security
- Pathname includes cloud name for additional security
- Preserving existing external domains (Facebook, Google) from original config to avoid breaking Maps/social embeds
- CSP updated to allow Cloudinary images (img-src) and videos (media-src) for future Phase 3

Why NOT wildcard hostname:
- Research flagged security risk: `hostname: '**'` allows ANY external domain
- Specific hostnames prevent accidental external image loading from untrusted sources
  </action>
  <verify>
- grep "unoptimized" next.config.js returns nothing (optimization enabled)
- grep "res.cloudinary.com" next.config.js confirms Cloudinary in remotePatterns and CSP
- grep "hostname: '\\*\\*'" next.config.js returns nothing (wildcard removed)
- npm run build succeeds
  </verify>
  <done>Next.js Image optimization enabled with Cloudinary CDN configured</done>
</task>

<task type="auto">
  <name>Task 3: Update ImageAsset type documentation</name>
  <files>src/app/api/gallery/types.ts</files>
  <action>
Update the comment on ImageAsset.src field to reflect Cloudinary public_id instead of local path.

Change line 2 from:
```typescript
src: string; // Will now store local path like '/assets/gallery/filename.jpg'
```

To:
```typescript
src: string; // Cloudinary public_id (e.g., 'timber-threads/gallery/1234567890-image-name')
```

This is a documentation update only - the type itself is already correct (string), just clarifying what format the string contains after migration.
  </action>
  <verify>
- grep "Cloudinary public_id" src/app/api/gallery/types.ts confirms updated documentation
- tsc --noEmit passes
  </verify>
  <done>ImageAsset type documentation updated to reflect Cloudinary storage</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds with no errors
- [ ] Cloudinary upload code exists in POST handler
- [ ] Local filesystem operations removed from POST handler
- [ ] next.config.js has Image optimization enabled (no unoptimized flag)
- [ ] next.config.js remotePatterns includes res.cloudinary.com
- [ ] CSP headers include Cloudinary domains
- [ ] ImageAsset type documents Cloudinary public_id format
</verification>

<success_criteria>
- All tasks completed
- Gallery images upload to Cloudinary instead of local filesystem
- Cloudinary public_id stored in Redis metadata
- Next.js Image optimization enabled
- All five Phase 1 requirements satisfied:
  - INFRA-01: Gallery metadata persists (Redis from Plan 01)
  - INFRA-02: Images stored on Cloudinary CDN (this plan)
  - INFRA-03: Signed uploads configured (Plan 02)
  - INFRA-04: Image optimization enabled (this plan)
  - INFRA-05: remotePatterns allows Cloudinary (this plan)
- Infrastructure ready for Phase 2 (Gallery Migration)
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-03-SUMMARY.md`
</output>

---
phase: 01-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/lib/redis.ts, src/app/api/gallery/route.ts]
autonomous: true
user_setup:
  - service: upstash-redis
    why: "Persistent metadata storage for gallery data"
    env_vars:
      - name: UPSTASH_REDIS_REST_URL
        source: "Vercel Dashboard → Storage → Upstash Redis → .env.local tab"
      - name: UPSTASH_REDIS_REST_TOKEN
        source: "Vercel Dashboard → Storage → Upstash Redis → .env.local tab"
    dashboard_config:
      - task: "Add Upstash Redis integration via Vercel Marketplace"
        location: "Vercel Dashboard → Storage → Create Database → Upstash Redis"
        details: "Select free tier, link to timber-threads project"
    local_dev:
      - "Run 'vercel env pull .env.local' to get Redis credentials locally"

must_haves:
  truths:
    - "Gallery metadata persists across Vercel deployments"
    - "Gallery API can read from Redis in development and production"
    - "Gallery API can write to Redis in development and production"
  artifacts:
    - path: "src/lib/redis.ts"
      provides: "Upstash Redis client and gallery data operations"
      min_lines: 30
      exports: ["redis", "getGalleryData", "saveGalleryData", "GalleryMetadata"]
    - path: "src/app/api/gallery/route.ts"
      provides: "Updated GET/POST/PATCH handlers using Redis instead of file system"
      contains: "import.*redis"
  key_links:
    - from: "src/app/api/gallery/route.ts"
      to: "src/lib/redis.ts"
      via: "import getGalleryData and saveGalleryData"
      pattern: "import.*\\{.*getGalleryData.*\\}.*from.*redis"
    - from: "src/lib/redis.ts"
      to: "Upstash Redis"
      via: "REST API using env vars"
      pattern: "process\\.env\\.UPSTASH_REDIS_REST"
---

<objective>
Replace file-based gallery metadata storage with Upstash Redis for production persistence.

Purpose: Fix critical production bug where gallery changes are lost on Vercel deployments due to read-only filesystem.
Output: Redis client library, migrated metadata storage, updated API handlers.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/phase-1-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STACK.md

@src/app/api/gallery/route.ts
@src/app/api/gallery/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Upstash Redis client</name>
  <files>package.json, package-lock.json</files>
  <action>
Install @upstash/redis package:

```bash
npm install @upstash/redis
```

This package uses HTTP REST API (not TCP connections), making it compatible with Vercel Edge Runtime and serverless environments.
  </action>
  <verify>grep "@upstash/redis" package.json confirms installation</verify>
  <done>@upstash/redis added to dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create Redis client and gallery data helpers</name>
  <files>src/lib/redis.ts</files>
  <action>
Create src/lib/redis.ts with Upstash Redis client configuration and type-safe gallery operations.

Implementation:

```typescript
import { Redis } from '@upstash/redis';
import { GalleryState } from '@/app/api/gallery/types';

// Initialize Upstash Redis client with REST API
export const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

// Type alias for clarity
export type GalleryMetadata = GalleryState;

/**
 * Fetch gallery data from Redis
 * Returns empty structure if key doesn't exist (first-time setup)
 */
export async function getGalleryData(): Promise<GalleryMetadata> {
  const data = await redis.get<GalleryMetadata>('gallery');
  return data || { images: [], deletedImages: [] };
}

/**
 * Save gallery data to Redis
 * Overwrites entire gallery key with new state
 */
export async function saveGalleryData(data: GalleryMetadata): Promise<void> {
  await redis.set('gallery', data);
}
```

Why this implementation:
- Uses HTTP REST API (no TCP) for Vercel Edge compatibility
- Simple key-value operations match current db.json structure
- Type-safe with existing GalleryState interface
- Returns default empty state on first read (no file not found errors)
- Free tier: 500K commands/month, 250MB storage - sufficient for retreat center traffic
  </action>
  <verify>
- tsc --noEmit passes (TypeScript compilation successful)
- grep "export.*redis" src/lib/redis.ts confirms exports
- grep "getGalleryData" src/lib/redis.ts confirms helper function exists
  </verify>
  <done>Redis client configured with gallery data operations exported</done>
</task>

<task type="auto">
  <name>Task 3: Migrate gallery API from file system to Redis</name>
  <files>src/app/api/gallery/route.ts</files>
  <action>
Update src/app/api/gallery/route.ts to replace all file system operations with Redis operations.

Changes required:

1. **Remove file system imports** (lines 2-3):
   ```typescript
   // DELETE THESE:
   // import { readFile, writeFile as fsWriteFile, mkdir } from 'fs/promises';
   // import path from 'path';
   ```

2. **Remove DB_PATH constant** (line 9):
   ```typescript
   // DELETE THIS:
   // const DB_PATH = path.join(process.cwd(), 'src', 'app', 'api', 'gallery', 'db.json');
   ```

3. **Add Redis import** (after existing imports):
   ```typescript
   import { getGalleryData, saveGalleryData } from '@/lib/redis';
   ```

4. **Replace getDB() function** (lines 11-18):
   ```typescript
   // REPLACE entire getDB function with just the import from redis.ts
   // The getGalleryData function already handles try-catch and default return
   ```

5. **Replace saveDB() function** (lines 20-43):
   ```typescript
   // REPLACE entire saveDB function with just the import from redis.ts
   // Remove all production environment checks - Redis works in all environments
   ```

6. **Update all function calls**:
   - Replace `getDB()` with `getGalleryData()` (appears in GET, POST, PATCH, DELETE handlers)
   - Replace `saveDB(db)` with `saveGalleryData(db)` (appears in POST, PATCH, DELETE handlers)

7. **Remove production warnings** (lines 331-349 in PATCH handler):
   ```typescript
   // DELETE the entire production environment check in updateOrder action
   // Redis persists in all environments, no special handling needed
   ```

Why NOT to include:
- Do NOT change Sharp image processing (Task handles metadata only, images migrate in Plan 03)
- Do NOT change file upload to public/assets/gallery yet (Plan 03 handles Cloudinary migration)
- Do NOT modify ImageAsset type definitions (already compatible)

Expected result: All metadata operations (fetch gallery, update caption, reorder, soft delete, restore, permanent delete) now persist via Redis in both development and production. The production file system warnings disappear.
  </action>
  <verify>
- grep "readFile\|writeFile\|DB_PATH" src/app/api/gallery/route.ts returns nothing (file ops removed)
- grep "getGalleryData\|saveGalleryData" src/app/api/gallery/route.ts confirms Redis operations used
- grep "VERCEL.*Production" src/app/api/gallery/route.ts returns nothing (production warnings removed)
- npm run build succeeds
  </verify>
  <done>Gallery API route uses Redis for all metadata operations with no file system dependencies</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds with no TypeScript errors
- [ ] Redis client exports verified in src/lib/redis.ts
- [ ] Gallery route imports from redis.ts confirmed
- [ ] All file system operations removed from gallery route
- [ ] Production environment warnings removed
</verification>

<success_criteria>
- All tasks completed
- Gallery metadata storage migrated from file system to Redis
- No file system operations remain in gallery API
- TypeScript compilation passes
- Code ready for Vercel deployment with persistent storage
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-01-SUMMARY.md`
</output>

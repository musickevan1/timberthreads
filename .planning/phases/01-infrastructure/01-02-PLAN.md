---
phase: 01-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/lib/cloudinary.ts, src/app/api/cloudinary-signature/route.ts, .env.local]
autonomous: true
user_setup:
  - service: cloudinary
    why: "Cloud image storage and CDN delivery"
    env_vars:
      - name: NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME
        source: "Cloudinary Dashboard → Settings → Account → Cloud name"
      - name: CLOUDINARY_API_KEY
        source: "Cloudinary Dashboard → Settings → API Keys → API Key"
      - name: CLOUDINARY_API_SECRET
        source: "Cloudinary Dashboard → Settings → API Keys → API Secret (NEVER use NEXT_PUBLIC_ prefix)"
    dashboard_config:
      - task: "Create upload preset for signed uploads"
        location: "Cloudinary Dashboard → Settings → Upload → Add upload preset"
        details: "Name: timber-threads-gallery, Signing Mode: Signed, Folder: timber-threads/gallery, Allowed formats: jpg,png,webp, Max file size: 10MB"
    local_dev:
      - "Add env vars to .env.local (API secret never exposed to client)"

must_haves:
  truths:
    - "Cloudinary SDK configured for server-side operations"
    - "Admin can request signed upload signatures from server"
    - "Cloudinary API credentials never exposed to client browser"
  artifacts:
    - path: "src/lib/cloudinary.ts"
      provides: "Cloudinary SDK configuration for server-side operations"
      min_lines: 10
      contains: "cloudinary.config"
      exports: ["cloudinary"]
    - path: "src/app/api/cloudinary-signature/route.ts"
      provides: "Signature generation endpoint for secure uploads"
      min_lines: 20
      exports: ["POST"]
      contains: "api_sign_request"
  key_links:
    - from: "src/app/api/cloudinary-signature/route.ts"
      to: "src/lib/cloudinary.ts"
      via: "import cloudinary config"
      pattern: "import.*cloudinary.*from.*cloudinary"
    - from: "src/lib/cloudinary.ts"
      to: "Cloudinary SDK"
      via: "cloudinary.config with API secret"
      pattern: "CLOUDINARY_API_SECRET"
---

<objective>
Configure Cloudinary SDK with signed upload security for admin image management.

Purpose: Enable secure cloud image storage with CDN delivery, replacing local filesystem storage that fails in Vercel production.
Output: Cloudinary SDK configuration, signature generation endpoint for secure uploads.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/phase-1-RESEARCH.md
@.planning/codebase/STACK.md
@.planning/codebase/CONVENTIONS.md

@src/app/api/gallery/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Cloudinary SDK configuration</name>
  <files>src/lib/cloudinary.ts</files>
  <action>
Create src/lib/cloudinary.ts with server-side Cloudinary SDK configuration.

Implementation:

```typescript
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary SDK with API credentials
// IMPORTANT: This file runs SERVER-SIDE ONLY - API secret never exposed to client
cloudinary.config({
  cloud_name: process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET, // NO NEXT_PUBLIC_ prefix - server-only
});

// Export configured instance for use in API routes
export { cloudinary };
```

Why this implementation:
- Uses 'cloudinary' v2 package (already in package.json at 2.5.1)
- CLOUDINARY_API_SECRET has NO NEXT_PUBLIC_ prefix - never exposed to browser
- NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME is safe to expose (needed for client-side CldImage components)
- CLOUDINARY_API_KEY is server-only (no NEXT_PUBLIC_ prefix)
- Configuration happens once at module load, reused across all API route invocations

Security note from research: Never add NEXT_PUBLIC_ to API_SECRET. This would expose your secret in the browser bundle, allowing anyone to upload unlimited content to your Cloudinary account and exhaust your quota.
  </action>
  <verify>
- tsc --noEmit passes
- grep "export.*cloudinary" src/lib/cloudinary.ts confirms export
- grep "NEXT_PUBLIC_CLOUDINARY_API_SECRET" src/lib/cloudinary.ts returns nothing (secret not exposed)
  </verify>
  <done>Cloudinary SDK configured with secure server-side credentials</done>
</task>

<task type="auto">
  <name>Task 2: Create signature generation endpoint</name>
  <files>src/app/api/cloudinary-signature/route.ts</files>
  <action>
Create src/app/api/cloudinary-signature/route.ts to generate upload signatures server-side.

Implementation:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { cloudinary } from '@/lib/cloudinary';

/**
 * POST /api/cloudinary-signature
 *
 * Generates signed upload signatures for Cloudinary uploads.
 * Required for secure admin uploads without exposing API secret to client.
 *
 * Request body: { paramsToSign: Record<string, any> }
 * Response: { signature: string }
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { paramsToSign } = body;

    if (!paramsToSign) {
      return NextResponse.json(
        { error: 'paramsToSign is required' },
        { status: 400 }
      );
    }

    // Generate signature using Cloudinary API secret (server-side only)
    // This prevents clients from uploading without authorization
    const signature = cloudinary.utils.api_sign_request(
      paramsToSign,
      process.env.CLOUDINARY_API_SECRET!
    );

    return NextResponse.json({ signature });
  } catch (error) {
    console.error('Error generating Cloudinary signature:', error);
    return NextResponse.json(
      { error: 'Failed to generate upload signature' },
      { status: 500 }
    );
  }
}
```

Why this pattern:
- Signature generated server-side using API secret (never exposed to client)
- CldUploadWidget (next-cloudinary) will call this endpoint during upload flow
- Cloudinary validates signature server-side, preventing unauthorized uploads
- Pattern from research: https://next.cloudinary.dev/clduploadwidget/signed-uploads

How it will be used (in Plan 03 when updating admin UI):
```typescript
<CldUploadWidget
  signatureEndpoint="/api/cloudinary-signature"
  uploadPreset="timber-threads-gallery"
  onSuccess={(result) => {
    // Update metadata in Redis via /api/gallery
  }}
/>
```

What NOT to do:
- Do NOT add rate limiting yet (future enhancement, not blocking for Phase 1)
- Do NOT add authentication check yet (admin auth is client-side sessionStorage, not implemented server-side)
- Do NOT implement the actual upload logic here (signature only, Cloudinary SDK handles upload)
  </action>
  <verify>
- mkdir -p src/app/api/cloudinary-signature (directory created if needed)
- tsc --noEmit passes
- grep "api_sign_request" src/app/api/cloudinary-signature/route.ts confirms signature generation
- grep "POST" src/app/api/cloudinary-signature/route.ts confirms POST handler export
  </verify>
  <done>Signature endpoint created for secure Cloudinary uploads</done>
</task>

<task type="auto">
  <name>Task 3: Document environment variables for local setup</name>
  <files>.env.local</files>
  <action>
Create or update .env.local with placeholder comments for Cloudinary credentials.

If .env.local exists, append to it. If not, create it.

Add these lines:

```bash
# Cloudinary Configuration (Phase 1: Infrastructure)
# Get credentials from: https://console.cloudinary.com/settings
# IMPORTANT: CLOUDINARY_API_SECRET is SERVER-ONLY - never use NEXT_PUBLIC_ prefix

NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=your_cloud_name_here
CLOUDINARY_API_KEY=your_api_key_here
CLOUDINARY_API_SECRET=your_api_secret_here
```

Also verify existing env vars are present. Expected existing vars (from INTEGRATIONS.md analysis):
- ADMIN_PASSWORD
- EMAIL_USER
- EMAIL_PASS
- RECIPIENT_EMAIL

If .env.local doesn't exist, create with all env vars documented. If it exists, just append Cloudinary section.

Note: .env.local is gitignored, so this file won't be committed. User will need to fill in actual values from Cloudinary dashboard.
  </action>
  <verify>
- cat .env.local | grep "CLOUDINARY" confirms Cloudinary env vars documented
- cat .env.local | grep "NEXT_PUBLIC_CLOUDINARY_API_SECRET" returns nothing (API secret not marked public)
  </verify>
  <done>Environment variable placeholders documented in .env.local</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds
- [ ] Cloudinary SDK configuration exists in src/lib/cloudinary.ts
- [ ] Signature endpoint exists at src/app/api/cloudinary-signature/route.ts
- [ ] No NEXT_PUBLIC_ prefix on CLOUDINARY_API_SECRET anywhere in codebase
- [ ] .env.local documents required Cloudinary env vars
</verification>

<success_criteria>
- All tasks completed
- Cloudinary SDK configured for server-side operations
- Signature generation endpoint ready for admin uploads
- Environment variables documented
- API secret never exposed to client (verified by grep)
- Code ready for Cloudinary integration in Plan 03
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-02-SUMMARY.md`
</output>

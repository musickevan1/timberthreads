---
phase: 01-infrastructure
plan: 04
type: execute
wave: 1
depends_on: []
files_modified: [src/app/api/gallery/route.ts]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Permanently deleting a Cloudinary-hosted image removes it from Cloudinary storage"
    - "Permanently deleting a local-path image skips Cloudinary deletion gracefully"
    - "Cloudinary deletion failure does not prevent Redis metadata cleanup"
  artifacts:
    - path: "src/app/api/gallery/route.ts"
      provides: "Cloudinary destroy call in DELETE handler"
      contains: "cloudinary.uploader.destroy"
  key_links:
    - from: "src/app/api/gallery/route.ts"
      to: "Cloudinary API"
      via: "cloudinary.uploader.destroy(public_id)"
      pattern: "cloudinary\\.uploader\\.destroy"
---

<objective>
Implement actual Cloudinary image deletion in the gallery DELETE handler, replacing the stub code that currently only logs a console message.

Purpose: Prevent orphaned images from accumulating in Cloudinary storage when admin permanently deletes gallery images. Without this, Cloudinary quota is consumed by unreferenced images indefinitely.

Output: Updated DELETE handler in src/app/api/gallery/route.ts with real cloudinary.uploader.destroy() call.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/01-03-SUMMARY.md
@src/app/api/gallery/route.ts
@src/app/api/gallery/types.ts
@src/lib/cloudinary.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Cloudinary deletion in DELETE handler</name>
  <files>src/app/api/gallery/route.ts</files>
  <action>
In the DELETE handler (starts at line 331), replace the stub code (lines 348-350) with actual Cloudinary deletion logic:

1. After finding `imageToDelete` from `db.deletedImages`, check if its `src` field is a Cloudinary public_id (does NOT start with `/` -- local paths start with `/assets/gallery/`).

2. If it is a Cloudinary public_id, call `cloudinary.uploader.destroy(imageToDelete.src)` to remove the image from Cloudinary storage. The `cloudinary` import already exists on line 5.

3. If it is a local path (starts with `/`), skip Cloudinary deletion -- local files are on the read-only Vercel filesystem and cannot be deleted from an API route anyway.

4. Wrap the Cloudinary destroy call in its own try/catch so that a Cloudinary API failure does NOT prevent the Redis metadata cleanup that follows. Log the error with `console.error` but continue with Redis deletion. This is important because the metadata cleanup (removing from deletedImages array in Redis) should always succeed even if external API calls fail -- otherwise the admin UI would show stale data.

5. Remove the two stub lines:
   - `console.log('Would delete from storage:', src);`
   - `// In a real implementation, we would delete the file from storage`

6. Add a log line after successful Cloudinary deletion: `console.log('Deleted from Cloudinary:', imageToDelete.src);`

The cloudinary SDK is already imported (line 5: `import { cloudinary } from '@/lib/cloudinary';`), so no new imports are needed. The `cloudinary.uploader.destroy()` method accepts a public_id string and returns a promise with `{ result: 'ok' }` on success.
  </action>
  <verify>
Run `npm run build` to confirm no TypeScript or build errors. Then grep the DELETE handler area for:
- No remaining "Would delete from storage" stub log
- No remaining "In a real implementation" comment
- Presence of `cloudinary.uploader.destroy` call
- Presence of try/catch around the destroy call (resilient to API failures)

Commands:
```
npm run build
grep -n "Would delete from storage" src/app/api/gallery/route.ts  # Should return nothing
grep -n "real implementation" src/app/api/gallery/route.ts  # Should return nothing
grep -n "cloudinary.uploader.destroy" src/app/api/gallery/route.ts  # Should return a match
```
  </verify>
  <done>
DELETE handler calls cloudinary.uploader.destroy(public_id) for Cloudinary-hosted images, skips gracefully for local paths, and handles Cloudinary API errors without blocking Redis cleanup. Build passes with no errors.
  </done>
</task>

</tasks>

<verification>
Phase 01 gap closure verification:
1. `npm run build` passes
2. `cloudinary.uploader.destroy` appears in DELETE handler
3. No stub comments remain in DELETE handler
4. Cloudinary deletion is wrapped in resilient try/catch (failure does not block Redis cleanup)
5. Local-path images (starting with `/`) are skipped for Cloudinary deletion
</verification>

<success_criteria>
- DELETE handler contains real Cloudinary deletion logic (not stub)
- Cloudinary-hosted images are deleted via cloudinary.uploader.destroy(public_id)
- Local-path images are handled gracefully (no error thrown)
- Cloudinary API failures do not prevent metadata cleanup in Redis
- Build compiles with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-04-SUMMARY.md`
</output>
